let data = {
  "cable_sizing": {
    "PVC": {
      "Copper": [
        { "size_mm2": 1.5, "current_air": 18, "current_buried": 22 },
        { "size_mm2": 2.5, "current_air": 24, "current_buried": 29 },
        { "size_mm2": 4, "current_air": 32, "current_buried": 37 },
        { "size_mm2": 6, "current_air": 41, "current_buried": 48 },
        { "size_mm2": 10, "current_air": 57, "current_buried": 67 },
        { "size_mm2": 16, "current_air": 76, "current_buried": 88 },
        { "size_mm2": 25, "current_air": 101, "current_buried": 117 },
        { "size_mm2": 35, "current_air": 125, "current_buried": 145 },
        { "size_mm2": 50, "current_air": 150, "current_buried": 175 },
        { "size_mm2": 70, "current_air": 185, "current_buried": 215 },
        { "size_mm2": 95, "current_air": 225, "current_buried": 260 },
        { "size_mm2": 120, "current_air": 260, "current_buried": 305 },
        { "size_mm2": 150, "current_air": 300, "current_buried": 355 },
        { "size_mm2": 185, "current_air": 340, "current_buried": 400 },
        { "size_mm2": 240, "current_air": 395, "current_buried": 460 },
        { "size_mm2": 300, "current_air": 455, "current_buried": 525 },
        { "size_mm2": 400, "current_air": 520, "current_buried": 600 },
        { "size_mm2": 500, "current_air": 590, "current_buried": 680 },
        { "size_mm2": 600, "current_air": 655, "current_buried": 760 }
      ],
      "Aluminium": [
        { "size_mm2": 2.5, "current_air": 22, "current_buried": 26 },
        { "size_mm2": 4, "current_air": 29, "current_buried": 34 },
        { "size_mm2": 6, "current_air": 37, "current_buried": 42 },
        { "size_mm2": 10, "current_air": 50, "current_buried": 58 },
        { "size_mm2": 16, "current_air": 66, "current_buried": 78 },
        { "size_mm2": 25, "current_air": 87, "current_buried": 100 },
        { "size_mm2": 35, "current_air": 110, "current_buried": 120 },
        { "size_mm2": 50, "current_air": 135, "current_buried": 150 },
        { "size_mm2": 70, "current_air": 165, "current_buried": 185 },
        { "size_mm2": 95, "current_air": 205, "current_buried": 230 },
        { "size_mm2": 120, "current_air": 235, "current_buried": 270 },
        { "size_mm2": 150, "current_air": 270, "current_buried": 310 },
        { "size_mm2": 185, "current_air": 310, "current_buried": 355 },
        { "size_mm2": 240, "current_air": 365, "current_buried": 410 },
        { "size_mm2": 300, "current_air": 420, "current_buried": 470 },
        { "size_mm2": 400, "current_air": 500, "current_buried": 540 },
        { "size_mm2": 500, "current_air": 580, "current_buried": 610 },
        { "size_mm2": 630, "current_air": 660, "current_buried": 680 }
      ]
    },
    "XLPE": {
      "Copper": [
        { "size_mm2": 1.5, "current_air": 20, "current_buried": 24 },
        { "size_mm2": 2.5, "current_air": 28, "current_buried": 32 },
        { "size_mm2": 4, "current_air": 37, "current_buried": 42 },
        { "size_mm2": 6, "current_air": 47, "current_buried": 52 },
        { "size_mm2": 10, "current_air": 65, "current_buried": 73 },
        { "size_mm2": 16, "current_air": 85, "current_buried": 95 },
        { "size_mm2": 25, "current_air": 115, "current_buried": 130 },
        { "size_mm2": 35, "current_air": 140, "current_buried": 160 },
        { "size_mm2": 50, "current_air": 170, "current_buried": 195 },
        { "size_mm2": 70, "current_air": 215, "current_buried": 240 },
        { "size_mm2": 95, "current_air": 260, "current_buried": 290 },
        { "size_mm2": 120, "current_air": 300, "current_buried": 340 },
        { "size_mm2": 150, "current_air": 340, "current_buried": 385 },
        { "size_mm2": 185, "current_air": 385, "current_buried": 435 },
        { "size_mm2": 240, "current_air": 445, "current_buried": 505 },
        { "size_mm2": 300, "current_air": 505, "current_buried": 575 },
        { "size_mm2": 400, "current_air": 570, "current_buried": 650 },
        { "size_mm2": 500, "current_air": 635, "current_buried": 725 },
        { "size_mm2": 600, "current_air": 700, "current_buried": 800 }
      ],
      "Aluminium": [
        { "size_mm2": 2.5, "current_air": 22, "current_buried": 26 },
        { "size_mm2": 4, "current_air": 29, "current_buried": 34 },
        { "size_mm2": 6, "current_air": 37, "current_buried": 42 },
        { "size_mm2": 10, "current_air": 50, "current_buried": 58 },
        { "size_mm2": 16, "current_air": 66, "current_buried": 78 },
        { "size_mm2": 25, "current_air": 87, "current_buried": 100 },
        { "size_mm2": 35, "current_air": 110, "current_buried": 120 },
        { "size_mm2": 50, "current_air": 135, "current_buried": 150 },
        { "size_mm2": 70, "current_air": 165, "current_buried": 185 },
        { "size_mm2": 95, "current_air": 205, "current_buried": 230 },
        { "size_mm2": 120, "current_air": 235, "current_buried": 270 },
        { "size_mm2": 150, "current_air": 270, "current_buried": 310 },
        { "size_mm2": 185, "current_air": 310, "current_buried": 355 },
        { "size_mm2": 240, "current_air": 365, "current_buried": 410 },
        { "size_mm2": 300, "current_air": 420, "current_buried": 470 },
        { "size_mm2": 400, "current_air": 500, "current_buried": 540 },
        { "size_mm2": 500, "current_air": 580, "current_buried": 610 },
        { "size_mm2": 630, "current_air": 660, "current_buried": 680 }
      ]
    }
  },
  "derating_factors": {
    "ambient": {
      "40C": 0.91,
      "50C": 0.87,
      "60C": 0.82
    },
    "grouping": {
      "2_cables": 0.8,
      "3_cables": 0.7
    }
  },
  "core_derating": {
    "1_core": 1.0,
    "2_core": 0.9,
    "3_core": 0.85,
    "3.5_core": 0.82,
    "4_core": 0.8
  },
  "busbar_sizing": {
    "Copper": {
      "current_density_A_per_mm2": 1.2,
      "density_kg_per_m3": 8960
    },
    "Aluminium": {
      "current_density_A_per_mm2": 0.8,
      "density_kg_per_m3": 2700
    }
  },
  "voltage_drop_limit_percent": 5
};

// Input validation functions
function validateNumericInput(value, min, max, fieldName) {
  const num = parseFloat(value);
  if (isNaN(num)) {
    throw new Error(`${fieldName} must be a number`);
  }
  if (num < min) {
    throw new Error(`${fieldName} must be at least ${min}`);
  }
  if (max !== undefined && num > max) {
    throw new Error(`${fieldName} must be at most ${max}`);
  }
  return num;
}

function validateConfiguration(config) {
  validateNumericInput(config.ambientTemp, 0, 60, "Ambient Temperature");
  validateNumericInput(config.loadCurrent, 0, 10000, "Load Current");
  validateNumericInput(config.length, 0.1, 10000, "Length");
  validateNumericInput(config.shortCircuitCurrent, 0, 100, "Short Circuit Current");
  validateNumericInput(config.shortCircuitDuration, 0.1, 10, "Short Circuit Duration");
  validateNumericInput(config.powerFactor, 0, 1, "Power Factor");
  validateNumericInput(config.num45Bends, 0, 100, "Number of 45° Bends");
  validateNumericInput(config.num90Bends, 0, 100, "Number of 90° Bends");
}

// Set default values for input fields
document.addEventListener('DOMContentLoaded', () => {
  document.getElementById("load-current").value = "100";
  document.getElementById("length").value = "50";
  document.getElementById("short-circuit-current").value = "10";
  document.getElementById("voltage").value = "415";

  // Add event listeners for input type selection
  document.getElementById("input-current").addEventListener("change", toggleInputType);
  document.getElementById("input-power").addEventListener("change", toggleInputType);
  document.getElementById("system-type").addEventListener("change", updatePowerLabel);
  document.getElementById("phase-config").addEventListener("change", updatePowerLabel);
  
  // Add event listener for cable size filter
  document.getElementById("enable-size-filter").addEventListener("change", function() {
    document.getElementById("cable-sizes").disabled = !this.checked;
  });

  document.getElementById("type").addEventListener("change", toggleTypeFields);
  toggleTypeFields();
});

function toggleInputType() {
  const currentInput = document.getElementById("current-input");
  const powerInput = document.getElementById("power-input");
  const isCurrent = document.getElementById("input-current").checked;
  
  currentInput.style.display = isCurrent ? "block" : "none";
  powerInput.style.display = isCurrent ? "none" : "block";
  
  updatePowerLabel();
}

function updatePowerLabel() {
  const systemType = document.getElementById("system-type").value;
  const powerLabel = document.getElementById("load-power").previousElementSibling;
  if (systemType === "ac") {
    powerLabel.textContent = "Load Power (kVA):";
  } else {
    powerLabel.textContent = "Load Power (kW):";
  }
}

function calculateCurrentFromPower(cfg) {
  const power = parseFloat(document.getElementById("load-power").value);
  if (isNaN(power)) {
    throw new Error("Power must be a number");
  }
  
  if (cfg.systemType === "ac") {
    // For AC systems
    const voltage = parseFloat(document.getElementById("voltage").value);
    const powerFactor = parseFloat(document.getElementById("power-factor").value);
    
    if (cfg.phaseConfig === "3phase-star" || cfg.phaseConfig === "3phase-delta") {
      // 3-phase system
      return (power * 1000) / (Math.sqrt(3) * voltage * powerFactor);
    } else {
      // 1-phase system
      return (power * 1000) / (voltage * powerFactor);
    }
  } else {
    // For DC systems
    const voltage = parseFloat(document.getElementById("voltage").value);
    return (power * 1000) / voltage;
  }
}

// Helper: get selected or all material combinations
function getFilteredMaterialCombinations(cfg) {
  let conductors = [];
  let insulations = [];
  if (cfg.conductorMaterial === 'both') {
    conductors = ['Copper', 'Aluminium'];
  } else {
    conductors = [cfg.conductorMaterial.charAt(0).toUpperCase() + cfg.conductorMaterial.slice(1)];
  }
  if (cfg.type === 'busbar') {
    insulations = [null];
  } else if (cfg.insulationType === 'both') {
    insulations = ['XLPE', 'PVC'];
  } else {
    insulations = [cfg.insulationType.toUpperCase()];
  }
  return { conductors, insulations };
}

// Helper: get busbar size options (stub, you can expand this list)
function getBusbarSizes(conductor) {
  // Example: standard busbar cross-sectional areas in mm²
  // You can expand or load this from IS standards
  return [
    { size_mm2: 80 },
    { size_mm2: 100 },
    { size_mm2: 120 },
    { size_mm2: 150 },
    { size_mm2: 200 },
    { size_mm2: 250 },
    { size_mm2: 300 },
    { size_mm2: 400 },
    { size_mm2: 500 },
    { size_mm2: 630 },
    { size_mm2: 800 },
    { size_mm2: 1000 }
  ];
}

// Standalone calculateSize function for a single config
function calculateSize(cfg, insulation, conductor, size) {
  const deratingAmbient = data.derating_factors.ambient[cfg.ambientTemp + "C"] || 1;
  const deratingGroup = cfg.installationMethod === "grouped" ? data.derating_factors.grouping["3_cables"] : 1;
  const coreKey = `${cfg.numCores}_core`;
  const coreDerating = data.core_derating[coreKey] || 1.0;
  let baseCurrent = size.current_air;
  if (cfg.installationMethod === 'buried') baseCurrent = size.current_buried;
  const adjustedCurrent = baseCurrent * deratingAmbient * deratingGroup * coreDerating;

  // Temperature-adjusted resistivity
  // ρ_T = ρ_20 * (1 + α * (T - 20))
  let rho20, alpha;
  if (conductor === 'Aluminium') {
    rho20 = 0.028;
    alpha = 0.00403;
  } else {
    rho20 = 0.017;
    alpha = 0.00393;
  }
  const T = cfg.ambientTemp;
  const resistivity = rho20 * (1 + alpha * (T - 20));

  // Calculate resistance (Ω)
  const resistance = resistivity * cfg.length / size.size_mm2;

  // Calculate voltage drop (V)
  let voltageDrop = 0;
  if (cfg.systemType === 'ac') {
    if (cfg.phaseConfig === '3phase-star' || cfg.phaseConfig === '3phase-delta') {
      voltageDrop = Math.sqrt(3) * cfg.loadCurrent * resistance * cfg.powerFactor;
    } else {
      voltageDrop = 2 * cfg.loadCurrent * resistance * cfg.powerFactor;
    }
  } else {
    voltageDrop = 2 * cfg.loadCurrent * resistance;
  }

  // Calculate voltage drop percent
  const voltage = parseFloat(document.getElementById("voltage").value);
  const voltageDropPercent = (voltageDrop / voltage) * 100;

  // Calculate power loss (W)
  const powerLoss = Math.pow(cfg.loadCurrent, 2) * resistance;

  // Short circuit area
  const kFactor = insulation === "XLPE" ? 226 : 143;
  const Isc = cfg.shortCircuitCurrent * 1000;
  const areaShortCircuit = (Isc * Math.sqrt(cfg.shortCircuitDuration)) / kFactor;
  let comment = '';
  if (size.size_mm2 < areaShortCircuit) {
    comment = 'WARNING: Short circuit area not met!';
  }
  if (adjustedCurrent < cfg.loadCurrent) {
    comment += (comment ? ' ' : '') + 'WARNING: Cable undersized for load!';
  }
  return {
    insulation,
    conductor,
    size: size.size_mm2,
    voltageDropPercent,
    voltageDrop,
    powerLoss,
    areaShortCircuit,
    adjustedCurrent,
    comment
  };
}

// Update CSV export to use current form values only
document.getElementById("download-csv").addEventListener("click", () => {
  const cfg = getCurrentConfigFromForm();
  const { conductors, insulations } = getFilteredMaterialCombinations(cfg);
  let csv = "";
  if (cfg.type === 'cable') {
    csv = "Type,Conductor,Insulation,Size (mm²),Voltage Drop %,Voltage Drop (V),Power Loss (W),Short Circuit Area (mm²),Recommended,Comments\n";
    for (const insulation of insulations) {
      for (const conductor of conductors) {
        const sizesData = data.cable_sizing[insulation]?.[conductor];
        if (!sizesData) continue;
        for (const size of sizesData) {
          const r = calculateSize(cfg, insulation, conductor, size);
          let recommended = '';
          const minSize = sizesData.find(s => {
            let base = s.current_air;
            if (cfg.installationMethod === 'buried') base = s.current_buried;
            const deratingAmbient = data.derating_factors.ambient[cfg.ambientTemp + "C"] || 1;
            const deratingGroup = cfg.installationMethod === "grouped" ? data.derating_factors.grouping["3_cables"] : 1;
            const coreKey = `${cfg.numCores}_core`;
            const coreDerating = data.core_derating[coreKey] || 1.0;
            const adj = base * deratingAmbient * deratingGroup * coreDerating;
            return adj >= cfg.loadCurrent;
          });
          if (minSize && minSize.size_mm2 === size.size_mm2) {
            recommended = '✔';
          }
          csv += `${cfg.type},${conductor},${insulation},${r.size},${r.voltageDropPercent.toFixed(2)},${r.voltageDrop.toFixed(2)},${r.powerLoss.toFixed(2)},${r.areaShortCircuit.toFixed(1)},${recommended},${r.comment}\n`;
        }
      }
    }
  } else {
    csv = "Type,Conductor,Required Size (mm²),Voltage Drop %,Voltage Drop (V),Power Loss (W),Short Circuit Area (mm²),Weight (g),Comments\n";
    for (const conductor of conductors) {
      // Get derating factors
      let insulationFactor = 1.0;
      if (cfg.busbarInsulationType === 'heat-shrink') insulationFactor = 0.95;
      if (cfg.busbarInsulationType === 'epoxy') insulationFactor = 0.9;
      const bendFactor = Math.pow(0.98, cfg.num45Bends || 0) * Math.pow(0.95, cfg.num90Bends || 0);
      const currentDensity = data.busbar_sizing[conductor].current_density_A_per_mm2;
      const required_mm2 = cfg.loadCurrent / (currentDensity * insulationFactor * bendFactor);
      const size = { size_mm2: required_mm2 };
      const r = calculateBusbarSize(cfg, conductor, size, insulationFactor, bendFactor);
      csv += `${cfg.type},${conductor},${required_mm2.toFixed(2)},${r.voltageDropPercent.toFixed(2)},${r.voltageDrop.toFixed(2)},${r.powerLoss.toFixed(2)},${r.areaShortCircuit.toFixed(1)},${r.weight.toFixed(0)},${r.comment}\n`;
    }
  }
  const blob = new Blob([csv], { type: "text/csv" });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = "cable_busbar_sizing.csv";
  a.click();
  URL.revokeObjectURL(url);
});

document.getElementById("download-config").addEventListener("click", () => {
  const cfg = getCurrentConfigFromForm();
  const blob = new Blob([JSON.stringify(cfg, null, 2)], { type: "application/json" });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = "sizing_config.json";
  a.click();
  URL.revokeObjectURL(url);
});

// Add handler for the top upload button to load config and calculate
const uploadTop = document.getElementById('upload-config-top');
if (uploadTop) {
  uploadTop.addEventListener('change', (event) => {
    const file = event.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = (e) => {
      try {
        const cfg = JSON.parse(e.target.result);
        setFormFromConfig(cfg);
        // Trigger calculation after loading config
        document.getElementById('calculate').click();
      } catch (err) {
        alert("Invalid JSON file");
      }
    };
    reader.readAsText(file);
  });
}

// Remove the old upload-config handler if not needed
const uploadOld = document.getElementById('upload-config');
if (uploadOld) {
  uploadOld.style.display = 'none';
}

// Add tooltips to input fields
document.addEventListener('DOMContentLoaded', () => {
  const tooltips = {
    'load-current': 'The maximum current that will flow through the cable/busbar',
    'length': 'The total length of the cable run in meters',
    'short-circuit-current': 'The maximum short circuit current in kiloamperes',
    'short-circuit-duration': 'The duration of the short circuit in seconds (typically 1s)',
    'power-factor': 'Power factor for AC systems (between 0 and 1)',
    'ambient-temp': 'The surrounding temperature in degrees Celsius'
  };

  for (const [id, text] of Object.entries(tooltips)) {
    const element = document.getElementById(id);
    if (element) {
      const tooltip = document.createElement('span');
      tooltip.className = 'tooltip';
      tooltip.setAttribute('data-tooltip', text);
      tooltip.textContent = '?';
      element.parentNode.insertBefore(tooltip, element.nextSibling);
    }
  }
});

function calculatePowerFromCurrent(cfg) {
  const current = parseFloat(document.getElementById("load-current").value);
  const voltage = parseFloat(document.getElementById("voltage").value);
  const powerFactor = parseFloat(document.getElementById("power-factor").value);
  
  if (cfg.systemType === "ac") {
    if (cfg.phaseConfig === "3phase-star" || cfg.phaseConfig === "3phase-delta") {
      // 3-phase system
      return (Math.sqrt(3) * voltage * current * powerFactor) / 1000; // in kVA
    } else {
      // 1-phase system
      return (voltage * current * powerFactor) / 1000; // in kVA
    }
  } else {
    // For DC systems
    return (voltage * current) / 1000; // in kW
  }
}

document.getElementById("calculate").addEventListener("click", async () => {
  const resultsDiv = document.getElementById("results");
  const cfg = getCurrentConfigFromForm();
  // Hardcoded voltage drop filter: 0-10%
  const vDropMin = 0;
  const vDropMax = 10;
  showLoading();
  try {
    let rows = "";
    let rowNum = 1;
    const { conductors, insulations } = getFilteredMaterialCombinations(cfg);
    
    // Calculate and display input summary
    const voltage = parseFloat(document.getElementById("voltage").value);
    let inputSummary = `<div class="input-summary">
      <h3>Input Summary</h3>
      <p>Voltage: ${voltage}V</p>`;
    
    if (document.getElementById("input-current").checked) {
      const current = parseFloat(document.getElementById("load-current").value);
      const calculatedPower = calculatePowerFromCurrent(cfg);
      inputSummary += `
        <p>Input Current: ${current.toFixed(2)}A</p>
        <p>Calculated Power: ${calculatedPower.toFixed(2)}${cfg.systemType === "ac" ? "kVA" : "kW"}</p>`;
    } else {
      const power = parseFloat(document.getElementById("load-power").value);
      const calculatedCurrent = cfg.loadCurrent;
      inputSummary += `
        <p>Input Power: ${power.toFixed(2)}${cfg.systemType === "ac" ? "kVA" : "kW"}</p>
        <p>Calculated Current: ${calculatedCurrent.toFixed(2)}A</p>`;
    }
    
    // Add cable size filter info if enabled
    if (document.getElementById("enable-size-filter").checked) {
      const selectedSizes = Array.from(document.getElementById("cable-sizes").selectedOptions)
        .map(option => option.value);
      if (selectedSizes.length > 0) {
        inputSummary += `<p>Filtered Cable Sizes: ${selectedSizes.join(", ")} mm²</p>`;
      }
    }
    
    inputSummary += `</div>`;
    resultsDiv.innerHTML = inputSummary;

    // Get selected cable sizes if filter is enabled
    const selectedSizes = cfg.enableSizeFilter ? cfg.selectedSizes : null;

    if (cfg.type === 'cable') {
      for (const insulation of insulations) {
        for (const conductor of conductors) {
          const sizesData = data.cable_sizing[insulation]?.[conductor];
          if (!sizesData) continue;
          for (const size of sizesData) {
            if (selectedSizes && !selectedSizes.includes(size.size_mm2)) continue;
            const r = calculateSize(cfg, insulation, conductor, size);
            if (r.voltageDropPercent < vDropMin || r.voltageDropPercent > vDropMax) continue;
            let recommended = '';
            const minSize = sizesData.find(s => {
              let base = s.current_air;
              if (cfg.installationMethod === 'buried') base = s.current_buried;
              const deratingAmbient = data.derating_factors.ambient[cfg.ambientTemp + "C"] || 1;
              const deratingGroup = cfg.installationMethod === "grouped" ? data.derating_factors.grouping["3_cables"] : 1;
              const coreKey = `${cfg.numCores}_core`;
              const coreDerating = data.core_derating[coreKey] || 1.0;
              const adj = base * deratingAmbient * deratingGroup * coreDerating;
              return adj >= cfg.loadCurrent;
            });
            if (minSize && minSize.size_mm2 === size.size_mm2) {
              recommended = '✔';
            }
            rows += `<tr>
              <td>${rowNum++}</td>
              <td>${cfg.type}</td>
              <td>${conductor}</td>
              <td>${insulation}</td>
              <td>${size.size_mm2}</td>
              <td>${r.voltageDropPercent.toFixed(2)}</td>
              <td>${r.voltageDrop.toFixed(2)}</td>
              <td>${r.powerLoss.toFixed(2)}</td>
              <td>${r.areaShortCircuit.toFixed(1)}</td>
              <td>${recommended}</td>
              <td>${r.comment}</td>
            </tr>`;
          }
        }
      }
    } else {
      // busbar: calculate required mm² and output a single result row
      for (const conductor of conductors) {
        // Get derating factors
        let insulationFactor = 1.0;
        if (cfg.busbarInsulationType === 'heat-shrink') insulationFactor = 0.95;
        if (cfg.busbarInsulationType === 'epoxy') insulationFactor = 0.9;
        const bendFactor = Math.pow(0.98, cfg.num45Bends || 0) * Math.pow(0.95, cfg.num90Bends || 0);
        // Get current density for busbar material
        const currentDensity = data.busbar_sizing[conductor].current_density_A_per_mm2;
        // Calculate required mm²
        const required_mm2 = cfg.loadCurrent / (currentDensity * insulationFactor * bendFactor);
        // Calculate all other parameters using this mm²
        const size = { size_mm2: required_mm2 };
        const r = calculateBusbarSize(cfg, conductor, size, insulationFactor, bendFactor);
        rows += `<tr>
          <td>${rowNum++}</td>
          <td>${cfg.type}</td>
          <td>${conductor}</td>
          <td>${required_mm2.toFixed(2)}</td>
          <td>${r.voltageDropPercent.toFixed(2)}</td>
          <td>${r.voltageDrop.toFixed(2)}</td>
          <td>${r.powerLoss.toFixed(2)}</td>
          <td>${r.areaShortCircuit.toFixed(1)}</td>
          <td>${r.weight.toFixed(0)}</td>
          <td>${r.comment}</td>
        </tr>`;
      }
    }
    if (rowNum === 1) {
      resultsDiv.innerHTML += `<p>No results found with voltage drop up to 10%</p>`;
    } else {
      let table = '';
      if (cfg.type === 'cable') {
        table = `
          <table>
            <tr>
              <th>#</th><th>Type</th><th>Conductor</th><th>Insulation</th><th>Size (mm²)</th><th>Voltage Drop %</th><th>Voltage Drop (V)</th><th>Power Loss (W)</th><th>Short Circuit Area (mm²)</th><th>Recommended</th><th>Comments</th>
            </tr>
            ${rows}
          </table>`;
      } else {
        table = `
          <table>
            <tr>
              <th>#</th><th>Type</th><th>Conductor</th><th>Required Size (mm²)</th><th>Voltage Drop %</th><th>Voltage Drop (V)</th><th>Power Loss (W)</th><th>Short Circuit Area (mm²)</th><th>Weight (g)</th><th>Comments</th>
            </tr>
            ${rows}
          </table>`;
      }
      resultsDiv.innerHTML += table;
    }
  } catch (error) {
    resultsDiv.innerHTML = `<p class="error-message">Error: ${error.message}</p>`;
  } finally {
    hideLoading();
  }
});

// Add a new function for busbar calculation
function calculateBusbarSize(cfg, conductor, size, insulationFactor, bendFactor) {
  // Temperature-adjusted resistivity
  let rho20, alpha;
  if (conductor === 'Aluminium') {
    rho20 = 0.028;
    alpha = 0.00403;
  } else {
    rho20 = 0.017;
    alpha = 0.00393;
  }
  const T = cfg.ambientTemp;
  const resistivity = rho20 * (1 + alpha * (T - 20));
  // Calculate resistance (Ω)
  const resistance = resistivity * cfg.length / size.size_mm2;
  // Voltage drop
  let voltageDrop = cfg.loadCurrent * resistance * insulationFactor * bendFactor;
  const voltage = parseFloat(document.getElementById("voltage").value);
  const voltageDropPercent = (voltageDrop / voltage) * 100;
  // Power loss
  const powerLoss = Math.pow(cfg.loadCurrent, 2) * resistance * insulationFactor * bendFactor;
  // Short circuit area (use copper kFactor for now)
  const kFactor = 143;
  const Isc = cfg.shortCircuitCurrent * 1000;
  const areaShortCircuit = (Isc * Math.sqrt(cfg.shortCircuitDuration)) / kFactor;
  // Weight (g) = area (mm²) * length (m) * density (kg/m³) / 1,000
  const density = data.busbar_sizing[conductor].density_kg_per_m3;
  const weight = size.size_mm2 * cfg.length * density / 1e3; // grams
  let comment = '';
  if (size.size_mm2 < areaShortCircuit) {
    comment = 'WARNING: Short circuit area not met!';
  }
  return {
    voltageDropPercent,
    voltageDrop,
    powerLoss,
    areaShortCircuit,
    weight,
    comment
  };
}

// Update getCurrentConfigFromForm to include busbar insulation type and handle length units
function getCurrentConfigFromForm() {
  const type = document.getElementById("type").value;
  const cfg = {
    type,
    systemType: document.getElementById("system-type").value,
    phaseConfig: document.getElementById("phase-config").value,
    conductorMaterial: document.getElementById("conductor-material").value,
    ambientTemp: parseFloat(document.getElementById("ambient-temp").value),
    length: parseFloat(document.getElementById("length").value),
    shortCircuitCurrent: parseFloat(document.getElementById("short-circuit-current").value),
    shortCircuitDuration: parseFloat(document.getElementById("short-circuit-duration").value),
    installationMethod: document.getElementById("installation-method").value,
    num45Bends: parseInt(document.getElementById("num-45-bends").value),
    num90Bends: parseInt(document.getElementById("num-90-bends").value),
    powerFactor: parseFloat(document.getElementById("power-factor").value),
    enableSizeFilter: document.getElementById("enable-size-filter").checked,
    selectedSizes: document.getElementById("enable-size-filter").checked
      ? Array.from(document.getElementById("cable-sizes").selectedOptions)
          .map(option => parseFloat(option.value))
      : null
  };
  if (type === "cable") {
    cfg.insulationType = document.getElementById("insulation-type").value;
    cfg.numCores = parseFloat(document.getElementById("num-cores").value);
    // Length in meters
  } else {
    cfg.busbarInsulationType = document.getElementById("busbar-insulation-type").value;
    // Convert length from mm to m for calculation
    cfg.length = cfg.length / 1000;
  }
  if (document.getElementById("input-current").checked) {
    cfg.loadCurrent = parseFloat(document.getElementById("load-current").value);
  } else {
    cfg.loadCurrent = calculateCurrentFromPower(cfg);
  }
  return cfg;
}

// Update setFormFromConfig to handle cable/busbar fields
function setFormFromConfig(cfg) {
  document.getElementById("type").value = cfg.type;
  toggleTypeFields();
  document.getElementById("system-type").value = cfg.systemType;
  document.getElementById("phase-config").value = cfg.phaseConfig;
  document.getElementById("conductor-material").value = cfg.conductorMaterial;
  document.getElementById("ambient-temp").value = cfg.ambientTemp;
  if (cfg.type === "cable") {
    document.getElementById("insulation-type").value = cfg.insulationType;
    document.getElementById("num-cores").value = cfg.numCores;
    document.getElementById("length").value = cfg.length;
  } else {
    document.getElementById("busbar-insulation-type").value = cfg.busbarInsulationType;
    document.getElementById("num-45-bends").value = cfg.num45Bends;
    document.getElementById("num-90-bends").value = cfg.num90Bends;
    document.getElementById("length").value = cfg.length * 1000;
  }
  document.getElementById("load-current").value = cfg.loadCurrent;
  document.getElementById("short-circuit-current").value = cfg.shortCircuitCurrent;
  document.getElementById("short-circuit-duration").value = cfg.shortCircuitDuration;
  document.getElementById("installation-method").value = cfg.installationMethod;
  document.getElementById("power-factor").value = cfg.powerFactor;
  // Set cable size filter if it exists in the config
  if (cfg.enableSizeFilter !== undefined) {
    document.getElementById("enable-size-filter").checked = cfg.enableSizeFilter;
    document.getElementById("cable-sizes").disabled = !cfg.enableSizeFilter;
    
    if (cfg.selectedSizes) {
      const sizeSelect = document.getElementById("cable-sizes");
      Array.from(sizeSelect.options).forEach(option => {
        option.selected = cfg.selectedSizes.includes(parseFloat(option.value));
      });
    }
  }
  
  // Set input type to current by default when loading config
  document.getElementById("input-current").checked = true;
  document.getElementById("input-power").checked = false;
  toggleInputType();
}

function toggleTypeFields() {
  const type = document.getElementById("type").value;
  const cableFields = document.getElementById("cable-fields");
  const busbarFields = document.getElementById("busbar-fields");
  const lengthLabel = document.getElementById("length-label");
  if (type === "cable") {
    cableFields.style.display = "block";
    busbarFields.style.display = "none";
    lengthLabel.textContent = "Length (m):";
  } else {
    cableFields.style.display = "none";
    busbarFields.style.display = "block";
    lengthLabel.textContent = "Length (mm):";
  }
}

function showLoading() {
  document.body.classList.add('loading');
}

function hideLoading() {
  document.body.classList.remove('loading');
}
